<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Image Resizer & Converter</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
    
    <style>
        /* --- Cyber Neon Theme: Deep Navy Blue & Electric Violet/Neon Cyan --- */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;900&display=swap');
        
        /* Define Theme Colors */
        :root {
            --dark-bg: #0a1128;      /* Deep Navy Blue */
            --dark-card: rgba(255, 255, 255, 0.05);    /* Glassmorphism Card */
            --accent-violet: #8a2be2;/* Primary Action Violet */
            --accent-cyan: #00f7ff;  /* Secondary/Glow Cyan */
            --text-color: #F0F0F0;   /* Light Text */
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--dark-bg); 
            color: var(--text-color);
            overflow-x: hidden;
            position: relative;
        }

        /* Floating background shapes */
        .floating-shape {
            position: absolute;
            z-index: -1;
            opacity: 0.3;
            animation: float 20s infinite linear;
        }
        
        .shape-1 {
            width: 200px;
            height: 200px;
            background: linear-gradient(135deg, var(--accent-violet), var(--accent-cyan));
            border-radius: 30% 70% 70% 30% / 30% 30% 70% 70%;
            top: 10%;
            left: 5%;
            animation-delay: 0s;
        }
        
        .shape-2 {
            width: 150px;
            height: 150px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-violet));
            border-radius: 60% 40% 30% 70% / 60% 30% 70% 40%;
            top: 60%;
            right: 10%;
            animation-delay: -5s;
        }
        
        .shape-3 {
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, var(--accent-violet), var(--accent-cyan));
            border-radius: 50% 20% 20% 50% / 50% 40% 60% 50%;
            bottom: 10%;
            left: 15%;
            animation-delay: -10s;
        }
        
        @keyframes float {
            0% {
                transform: translate(0, 0) rotate(0deg) scale(1);
            }
            33% {
                transform: translate(30px, -50px) rotate(120deg) scale(1.1);
            }
            66% {
                transform: translate(-20px, 20px) rotate(240deg) scale(0.9);
            }
            100% {
                transform: translate(0, 0) rotate(360deg) scale(1);
            }
        }

        /* Card and Glassmorphism */
        .container-card {
            background: var(--dark-card); 
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 
                0 10px 30px rgba(0, 0, 0, 0.4),
                0 0 20px rgba(138, 43, 226, 0.2),
                0 0 40px rgba(0, 247, 255, 0.1);
            transition: all 0.3s ease;
        }
        
        .container-card:hover {
            transform: translateY(-5px);
            box-shadow: 
                0 15px 40px rgba(0, 0, 0, 0.5),
                0 0 30px rgba(138, 43, 226, 0.3),
                0 0 50px rgba(0, 247, 255, 0.2);
        }

        /* Action Buttons */
        .btn-action {
            background: linear-gradient(135deg, var(--accent-violet), var(--accent-cyan));
            color: var(--dark-bg);
            transition: all 0.3s;
            font-weight: 600;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.4);
            z-index: 1;
        }
        
        .btn-action::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: all 0.5s;
            z-index: -1;
        }

        .btn-action:hover:enabled {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(138, 43, 226, 0.6), 0 0 15px rgba(0, 247, 255, 0.5);
        }
        
        .btn-action:hover:enabled::before {
            left: 100%;
        }
        
        .btn-action:disabled {
            background: #4A4A4A;
            color: #888;
            box-shadow: none;
            cursor: not-allowed;
            transform: none;
        }

        /* Drop Zones */
        .drop-zone {
            border: 2px dashed rgba(255, 255, 255, 0.2);
            transition: all 0.3s;
            background: rgba(255, 255, 255, 0.02);
            backdrop-filter: blur(10px);
        }

        .drop-zone-active {
            border-color: var(--accent-cyan);
            background-color: rgba(0, 247, 255, 0.05);
            box-shadow: 0 0 15px rgba(0, 247, 255, 0.3);
        }
        
        /* Custom range slider */
        input[type="range"] {
            -webkit-appearance: none;
            height: 6px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-violet), var(--accent-cyan));
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 247, 255, 0.5);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-violet), var(--accent-cyan));
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(0, 247, 255, 0.5);
        }
        
        /* Input fields */
        .custom-input {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
            backdrop-filter: blur(5px);
            color: var(--text-color);
        }
        
        .custom-input:focus {
            border-color: var(--accent-cyan);
            box-shadow: 0 0 10px rgba(0, 247, 255, 0.3);
        }
        
        /* Custom dropdown styling */
        select.custom-input option {
            background: #1a1a2e;
            color: var(--text-color);
            padding: 8px;
        }
        
        /* Section headers */
        .section-header {
            position: relative;
            display: inline-block;
            padding-bottom: 8px;
        }
        
        .section-header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--accent-violet), var(--accent-cyan));
            transition: width 0.5s ease;
        }
        
        .section-header:hover::after {
            width: 100%;
        }
        
        /* Preview container */
        #previewContainer {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            transition: all 0.3s;
        }
        
        /* Color input */
        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            border-radius: 5px;
            height: 40px;
            cursor: pointer;
        }
        
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        
        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 5px;
        }
        
        /* Status message animation */
        #statusMessage {
            transition: all 0.3s ease;
        }
        
        /* Responsive optimizations */
        @media (max-width: 768px) {
            .floating-shape {
                display: none;
            }
            
            .container-card:hover {
                transform: none;
            }
        }
        
        @media (max-width: 576px) {
            .container-card {
                padding: 1rem;
            }
        }
    </style>
</head>
<body class="min-h-screen p-4 md:p-8 flex items-start justify-center">

    <!-- Floating background shapes -->
    <div class="floating-shape shape-1"></div>
    <div class="floating-shape shape-2"></div>
    <div class="floating-shape shape-3"></div>

    <div id="appContainer" class="w-full max-w-6xl container-card rounded-xl p-6 md:p-8 mt-10">
        <h1 class="text-3xl md:text-4xl font-black text-center mb-6 text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-violet-600">
            Image Optimizer: Resize and Convert
        </h1>
        <p class="text-center text-gray-400 mb-8">
            Upload an image to start optimizing. Processing happens entirely in your browser.
        </p>

        <!-- Status Message Area -->
        <div id="statusMessage" class="hidden p-3 rounded-lg text-sm text-center mb-6 backdrop-blur-md"></div>

        <!-- Main Content Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            
            <!-- Column 1: File Uploader & Preview -->
            <div class="lg:col-span-1">
                <h2 class="text-xl font-semibold mb-4 pb-2 section-header">1. Upload Image</h2>
                
                <div id="dropZone" class="drop-zone p-8 text-center rounded-lg cursor-pointer hover:drop-zone-active mb-4">
                    <i class="fas fa-upload text-3xl text-gray-500 mb-2"></i>
                    <p class="text-gray-400 font-medium">Drag & Drop or Click to Upload</p>
                    <p class="text-xs text-gray-500 mt-1">PNG, JPG, WebP, GIF supported</p>
                </div>
                <input type="file" id="fileInput" accept="image/*" class="hidden">

                <div id="previewContainer" class="rounded-lg p-2 flex items-center justify-center min-h-48 relative">
                    <p id="placeholderText" class="text-gray-500 italic">No image selected</p>
                    <img id="imagePreview" src="" alt="Image Preview" class="hidden max-w-full max-h-96 rounded-md shadow-lg">
                    <div id="imageInfo" class="hidden absolute top-0 right-0 m-2 bg-black/50 text-xs p-1 rounded backdrop-blur-sm"></div>
                </div>
            </div>

            <!-- Column 2: Resize Options (with Conversion Included) -->
            <div class="lg:col-span-1">
                <h2 class="text-xl font-semibold mb-4 pb-2 section-header">2. Resize</h2>
                <p class="text-gray-400 text-sm mb-4">Set new dimensions. Conversion settings from Section 3 will also apply.</p>

                <div class="space-y-4">
                    <!-- Width Input -->
                    <div>
                        <label for="widthInput" class="block text-sm font-medium mb-1">Target Width (px)</label>
                        <input type="number" id="widthInput" placeholder="Original Width" class="w-full p-2 custom-input rounded-md focus:border-accent-cyan focus:ring focus:ring-cyan-500/30" min="1">
                        <p class="text-xs text-gray-400 mt-1">Leave blank to scale proportionally by height.</p>
                    </div>

                    <!-- Height Input -->
                    <div>
                        <label for="heightInput" class="block text-sm font-medium mb-1">Target Height (px)</label>
                        <input type="number" id="heightInput" placeholder="Original Height" class="w-full p-2 custom-input rounded-md focus:border-accent-cyan focus:ring focus:ring-cyan-500/30" min="1">
                        <p class="text-xs text-gray-400 mt-1">Leave blank to scale proportionally by width.</p>
                    </div>
                </div>
                
                <button id="resizeBtn" class="btn-action w-full mt-6 py-3 rounded-lg disabled:opacity-50" disabled>
                    <i class="fas fa-arrows-alt-h mr-2"></i> Resize & Download
                </button>
            </div>

            <!-- Column 3: Conversion Options (Convert Only) -->
            <div class="lg:col-span-1">
                <h2 class="text-xl font-semibold mb-4 pb-2 section-header">3. Convert Only</h2>
                <p class="text-gray-400 text-sm mb-4">Change format or quality without changing size.</p>

                <div class="space-y-4">
                    <!-- Format Dropdown -->
                    <div>
                        <label for="targetFormatInput" class="block text-sm font-medium mb-1">Output Format</label>
                        <select id="targetFormatInput" class="w-full p-2 custom-input rounded-md focus:border-accent-cyan focus:ring focus:ring-cyan-500/30">
                            <option value="original">Original Format</option>
                            <option value="image/jpeg">JPEG (.jpg)</option>
                            <option value="image/png">PNG (.png)</option>
                            <option value="image/webp">WebP (.webp)</option>
                        </select>
                    </div>

                    <!-- Quality Slider -->
                    <div>
                        <label for="conversionQualityInput" class="block text-sm font-medium mb-1 flex justify-between">
                            <span>Quality (for JPG/WebP)</span>
                            <span id="qualityValue">90%</span>
                        </label>
                        <input type="range" id="conversionQualityInput" min="10" max="100" value="90" step="5" class="w-full h-2 rounded-lg cursor-pointer">
                        <p class="text-xs text-gray-400 mt-1">Lower quality reduces file size significantly.</p>
                    </div>

                    <!-- Background Color Input -->
                    <div>
                        <label for="bgColorInput" class="block text-sm font-medium mb-1">Background Color (for JPG)</label>
                        <input type="color" id="bgColorInput" value="#0a1128" class="w-full h-10 p-1 custom-input rounded-md cursor-pointer">
                        <p class="text-xs text-gray-400 mt-1">Used if converting transparent PNG/GIF to JPG.</p>
                    </div>
                </div>

                <button id="convertBtn" class="btn-action w-full mt-6 py-3 rounded-lg disabled:opacity-50" disabled>
                    <i class="fas fa-exchange-alt mr-2"></i> Convert Only & Download
                </button>
            </div>
        </div>

    </div>

    <script>
        // --- GLOBAL VARIABLES ---
        let globalFile = null;
        let globalImg = null;

        // --- UTILITY FUNCTIONS ---
        
        // Displays a message in the status area
        function displayMessage(message, type = 'info') {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.textContent = message;
            statusDiv.classList.remove('hidden', 'text-cyan-400', 'text-green-400', 'text-red-400', 'bg-red-900/30', 'bg-green-900/30', 'bg-cyan-900/30');

            if (type === 'success') {
                statusDiv.classList.add('text-green-400', 'bg-green-900/30');
            } else if (type === 'error') {
                statusDiv.classList.add('text-red-400', 'bg-red-900/30');
            } else {
                statusDiv.classList.add('text-cyan-400', 'bg-cyan-900/30');
            }
        }
        
        // Helper to calculate new dimensions while maintaining aspect ratio
        function calculateNewDimensions(originalWidth, originalHeight, targetWidth, targetHeight) {
            let newWidth = originalWidth;
            let newHeight = originalHeight;

            const reqWidth = targetWidth > 0 ? targetWidth : null;
            const reqHeight = targetHeight > 0 ? targetHeight : null;
            
            // If neither is requested, return original
            if (!reqWidth && !reqHeight) {
                return { width: originalWidth, height: originalHeight };
            }

            // Case 1: Both width and height are requested (fit inside box)
            if (reqWidth && reqHeight) {
                const widthRatio = reqWidth / originalWidth;
                const heightRatio = reqHeight / originalHeight;
                const ratio = Math.min(widthRatio, heightRatio);
                
                // If image is already smaller than requested box, don't upscale
                if (ratio >= 1) { 
                    newWidth = originalWidth;
                    newHeight = originalHeight;
                } else {
                    newWidth = originalWidth * ratio;
                    newHeight = originalHeight * ratio;
                }
            } 
            // Case 2: Only width is requested (scale proportionally)
            else if (reqWidth) {
                const ratio = reqWidth / originalWidth;
                newWidth = reqWidth;
                newHeight = originalHeight * ratio;
            } 
            // Case 3: Only height is requested (scale proportionally)
            else if (reqHeight) {
                const ratio = reqHeight / originalHeight;
                newWidth = originalWidth * ratio;
                newHeight = reqHeight;
            }
            
            // Return rounded integers
            return {
                width: Math.round(newWidth),
                height: Math.round(newHeight)
            };
        }

        // --- CORE PROCESSING LOGIC ---
        async function processImage(actionType) {
            displayMessage(`Starting image processing...`, 'info');
            
            if (!globalImg) {
                displayMessage('No image selected. Please upload an image first.', 'error');
                return;
            }

            try {
                const originalWidth = globalImg.naturalWidth;
                const originalHeight = globalImg.naturalHeight;
                let targetWidth = originalWidth;
                let targetHeight = originalHeight;
                
                const targetFormatInput = document.getElementById('targetFormatInput');
                const conversionQualityInput = document.getElementById('conversionQualityInput');
                const bgColorInput = document.getElementById('bgColorInput');

                let targetFormat = targetFormatInput.value; 
                let quality = parseFloat(conversionQualityInput.value) / 100;

                // --- 1. Determine Target Dimensions based on actionType ---
                if (actionType === 'resize') {
                    const widthInput = document.getElementById('widthInput');
                    const heightInput = document.getElementById('heightInput');
                    const reqWidth = parseInt(widthInput.value, 10);
                    const reqHeight = parseInt(heightInput.value, 10);
                    
                    if (reqWidth > 0 || reqHeight > 0) {
                        const calculated = calculateNewDimensions(
                            originalWidth, 
                            originalHeight, 
                            reqWidth, 
                            reqHeight
                        );
                        targetWidth = calculated.width;
                        targetHeight = calculated.height;
                    }
                } 
                // If actionType is 'convert', target dimensions remain original.

                // --- 2. Determine Target Format and Quality ---
                if (targetFormat === 'original') {
                    // Use original MIME type and default high quality
                    targetFormat = globalFile.type;
                    quality = 0.95; 
                }
                
                if (isNaN(quality) || quality < 0.1) quality = 0.9;
                
                displayMessage(`Processing image to ${targetWidth}x${targetHeight} in ${targetFormat} @ ${Math.round(quality * 100)}%...`, 'info');

                // --- 3. Canvas Creation and Drawing ---
                const canvas = document.createElement('canvas');
                canvas.width = targetWidth;
                canvas.height = targetHeight;
                const ctx = canvas.getContext('2d');
                
                // Fill background if converting to non-transparent format (e.g., JPG)
                if (targetFormat.includes('jpeg') || targetFormat.includes('webp')) {
                    ctx.fillStyle = bgColorInput.value;
                    ctx.fillRect(0, 0, targetWidth, targetHeight);
                }

                // Draw the image at the target size
                ctx.drawImage(globalImg, 0, 0, targetWidth, targetHeight);

                // --- 4. Blob Generation (Promisified) ---
                const blob = await new Promise((resolve, reject) => {
                    // Check if the browser supports the requested format for toBlob
                    try {
                        // NOTE: toBlob requires image/ format, not .extension format
                        canvas.toBlob(resolve, targetFormat, quality);
                    } catch (e) {
                        reject(new Error(`Browser error during toBlob: ${e.message}. Try another format.`));
                    }
                });

                if (!blob) {
                    throw new Error("Failed to generate image blob. Check format and quality settings.");
                }
                
                // --- 5. Downloading ---
                const downloadUrl = URL.createObjectURL(blob);
                
                // Create filename
                const originalName = globalFile.name.substring(0, globalFile.name.lastIndexOf('.')) || 'image';
                
                // Get extension from the target MIME type
                let extension = targetFormat.split('/').pop();
                if (extension === 'jpeg') extension = 'jpg';
                
                let fileName = `${originalName}_optimized.${extension}`;
                
                // Add dimensions to filename if resized
                if (targetWidth !== originalWidth || targetHeight !== originalHeight) {
                    const dimensionTag = `${targetWidth}x${targetHeight}`;
                    const parts = fileName.split('.');
                    parts.splice(parts.length - 1, 0, dimensionTag);
                    fileName = parts.join('.');
                }

                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // Clean up
                URL.revokeObjectURL(downloadUrl);
                
                displayMessage(`Success! Downloaded file: ${fileName} (${(blob.size / 1024).toFixed(2)} KB)`, 'success');

            } catch (error) {
                console.error("Image Processing Error:", error);
                displayMessage(`An error occurred during processing: ${error.message}`, 'error');
            }
        }

        // --- UI & EVENT HANDLERS ---

        // Checks if action buttons should be enabled
        function checkEnableButtons() {
            const resizeBtn = document.getElementById('resizeBtn');
            const convertBtn = document.getElementById('convertBtn');
            
            const widthValue = document.getElementById('widthInput').value.trim();
            const heightValue = document.getElementById('heightInput').value.trim();
            const targetFormat = document.getElementById('targetFormatInput').value;
            const qualityValue = document.getElementById('conversionQualityInput').value;
            document.getElementById('qualityValue').textContent = `${qualityValue}%`;

            const isImageLoaded = globalImg !== null;
            
            // Enable Resize button if image is loaded AND at least one dimension is set
            const canResize = isImageLoaded && (widthValue !== '' || heightValue !== '');
            resizeBtn.disabled = !canResize;
            
            // Enable Convert ONLY button if image is loaded AND format is not original OR quality is explicitly changed
            const isFormatChanged = targetFormat !== 'original';
            const isQualityChanged = qualityValue !== '90';
            
            const canConvert = isImageLoaded && (isFormatChanged || isQualityChanged);
            convertBtn.disabled = !canConvert;
        }
        
        // Handles file input change or drop event
        function handleFileSelection(file) {
            if (!file || !file.type.startsWith('image/')) {
                displayMessage('Please select a valid image file.', 'error');
                globalFile = null;
                globalImg = null;
                document.getElementById('imagePreview').classList.add('hidden');
                document.getElementById('imageInfo').classList.add('hidden');
                document.getElementById('placeholderText').classList.remove('hidden');
                checkEnableButtons();
                return;
            }

            globalFile = file;
            displayMessage(`Image selected: ${file.name}`, 'info');

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    globalImg = img;
                    
                    const preview = document.getElementById('imagePreview');
                    preview.src = img.src;
                    preview.classList.remove('hidden');
                    document.getElementById('placeholderText').classList.add('hidden');
                    
                    const info = document.getElementById('imageInfo');
                    info.textContent = `${img.naturalWidth} x ${img.naturalHeight} | ${(file.size / 1024).toFixed(1)} KB`;
                    info.classList.remove('hidden');
                    
                    // Clear and set placeholders
                    document.getElementById('widthInput').value = '';
                    document.getElementById('widthInput').placeholder = img.naturalWidth;
                    document.getElementById('heightInput').value = '';
                    document.getElementById('heightInput').placeholder = img.naturalHeight;
                    
                    checkEnableButtons();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        // --- INITIALIZATION ---
        function initApp() {
            const dropZone = document.getElementById('dropZone');
            const fileInput = document.getElementById('fileInput');
            const resizeBtn = document.getElementById('resizeBtn');
            const convertBtn = document.getElementById('convertBtn');
            const qualityInput = document.getElementById('conversionQualityInput');
            const widthInput = document.getElementById('widthInput');
            const heightInput = document.getElementById('heightInput');
            const targetFormatInput = document.getElementById('targetFormatInput');

            // --- Drop Zone Listeners ---
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
            });
            dropZone.addEventListener('dragenter', () => dropZone.classList.add('drop-zone-active'), false);
            dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drop-zone-active'), false);
            dropZone.addEventListener('drop', (e) => {
                preventDefaults(e);
                dropZone.classList.remove('drop-zone-active');
                const dt = e.dataTransfer;
                if (dt.files.length > 0) { handleFileSelection(dt.files[0]); }
            }, false);
            dropZone.onclick = () => fileInput.click();
            fileInput.onchange = (e) => {
                if (e.target.files.length > 0) { handleFileSelection(e.target.files[0]); }
            };

            // --- Action Button Listeners ---
            // 'resize' action will recalculate dimensions AND use conversion settings
            resizeBtn.addEventListener('click', () => processImage('resize'));
            
            // 'convert' action will use ORIGINAL dimensions AND conversion settings
            convertBtn.addEventListener('click', () => processImage('convert'));

            // --- Input Change Listeners (to check button status) ---
            widthInput.addEventListener('input', checkEnableButtons);
            heightInput.addEventListener('input', checkEnableButtons);
            qualityInput.addEventListener('input', checkEnableButtons);
            targetFormatInput.addEventListener('change', checkEnableButtons);
            
            // Set initial state
            checkEnableButtons();
        }

        window.onload = initApp;
    </script>
</body>
</html>
