<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom Image Resizer & Converter</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
    
    <style>
        /* --- Solar Flare Theme: Deep Charcoal & High-Energy Orange --- */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;900&display=swap');
        
        /* Define Theme Colors */
        :root {
            --dark-bg: #1A1A1A;      /* Deep Charcoal */
            --dark-card: #282828;    /* Slightly lighter card */
            --accent-orange: #FF9900;/* Primary Action Orange */
            --accent-gold: #FFD700;  /* Secondary/Glow Gold */
            --text-color: #F0F0F0;   /* Light Text */
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--dark-bg); 
            color: var(--text-color);
        }

        /* Card and Shadows */
        .container-card {
            background-color: var(--dark-card); 
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            border: 1px solid #3A3A3A;
        }

        /* Action Buttons */
        .btn-action {
            background-color: var(--accent-orange);
            color: var(--dark-bg);
            transition: all 0.2s;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(255, 153, 0, 0.5);
        }

        .btn-action:hover:enabled {
            background-color: var(--accent-gold);
            box-shadow: 0 4px 20px rgba(255, 215, 0, 0.7);
            transform: translateY(-1px);
        }
        
        .btn-action:disabled {
            background-color: #4A4A4A;
            color: #888;
            box-shadow: none;
            cursor: not-allowed;
        }

        /* Drop Zones */
        .drop-zone {
            border: 2px dashed #4A4A4A;
            transition: all 0.2s;
        }

        .drop-zone-active {
            border-color: var(--accent-orange);
            background-color: #383838;
        }
        
        /* Custom range slider thumb color */
        input[type="range"]::-webkit-slider-thumb {
            background: var(--accent-orange);
        }
        input[type="range"]::-moz-range-thumb {
            background: var(--accent-orange);
        }
    </style>
</head>
<body class="min-h-screen p-4 md:p-8 flex items-start justify-center">

    <div id="appContainer" class="w-full max-w-6xl container-card rounded-xl p-6 md:p-8 mt-10">
        <h1 class="text-3xl md:text-4xl font-black text-center mb-6 text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-orange-600">
            Image Optimizer: Resize and Convert
        </h1>
        <p class="text-center text-gray-400 mb-8">
            Upload an image to start optimizing. Processing happens entirely in your browser.
        </p>

        <!-- Status Message Area -->
        <div id="statusMessage" class="hidden p-3 rounded-lg text-sm text-center mb-6"></div>

        <!-- Main Content Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            
            <!-- Column 1: File Uploader & Preview -->
            <div class="lg:col-span-1">
                <h2 class="text-xl font-semibold mb-4 border-b border-gray-700 pb-2">1. Upload Image</h2>
                
                <div id="dropZone" class="drop-zone p-8 text-center rounded-lg cursor-pointer hover:drop-zone-active mb-4">
                    <i class="fas fa-upload text-3xl text-gray-500 mb-2"></i>
                    <p class="text-gray-400 font-medium">Drag & Drop or Click to Upload</p>
                    <p class="text-xs text-gray-500 mt-1">PNG, JPG, WebP, GIF supported</p>
                </div>
                <input type="file" id="fileInput" accept="image/*" class="hidden">

                <div id="previewContainer" class="bg-gray-800 rounded-lg p-2 flex items-center justify-center min-h-48 relative">
                    <p id="placeholderText" class="text-gray-500 italic">No image selected</p>
                    <img id="imagePreview" src="" alt="Image Preview" class="hidden max-w-full max-h-96 rounded-md shadow-lg">
                    <div id="imageInfo" class="hidden absolute top-0 right-0 m-2 bg-black/50 text-xs p-1 rounded"></div>
                </div>
            </div>

            <!-- Column 2: Resize Options (with Conversion Included) -->
            <div class="lg:col-span-1">
                <h2 class="text-xl font-semibold mb-4 border-b border-gray-700 pb-2">2. Resize</h2>
                <p class="text-gray-400 text-sm mb-4">Set new dimensions. Conversion settings from Section 3 will also apply.</p>

                <div class="space-y-4">
                    <!-- Width Input -->
                    <div>
                        <label for="widthInput" class="block text-sm font-medium mb-1">Target Width (px)</label>
                        <input type="number" id="widthInput" placeholder="Original Width" class="w-full p-2 bg-gray-700 border border-gray-600 rounded-md focus:border-accent-orange focus:ring focus:ring-accent-orange/50" min="1">
                        <p class="text-xs text-gray-400 mt-1">Leave blank to scale proportionally by height.</p>
                    </div>

                    <!-- Height Input -->
                    <div>
                        <label for="heightInput" class="block text-sm font-medium mb-1">Target Height (px)</label>
                        <input type="number" id="heightInput" placeholder="Original Height" class="w-full p-2 bg-gray-700 border border-gray-600 rounded-md focus:border-accent-orange focus:ring focus:ring-accent-orange/50" min="1">
                        <p class="text-xs text-gray-400 mt-1">Leave blank to scale proportionally by width.</p>
                    </div>
                </div>
                
                <button id="resizeBtn" class="btn-action w-full mt-6 py-3 rounded-lg disabled:opacity-50" disabled>
                    <i class="fas fa-arrows-alt-h mr-2"></i> Resize & Download
                </button>
            </div>

            <!-- Column 3: Conversion Options (Convert Only) -->
            <div class="lg:col-span-1">
                <h2 class="text-xl font-semibold mb-4 border-b border-gray-700 pb-2">3. Convert Only</h2>
                <p class="text-gray-400 text-sm mb-4">Change format or quality without changing size.</p>

                <div class="space-y-4">
                    <!-- Format Dropdown -->
                    <div>
                        <label for="targetFormatInput" class="block text-sm font-medium mb-1">Output Format</label>
                        <select id="targetFormatInput" class="w-full p-2 bg-gray-700 border border-gray-600 rounded-md focus:border-accent-orange focus:ring focus:ring-accent-orange/50">
                            <option value="original">Original Format</option>
                            <option value="image/jpeg">JPEG (.jpg)</option>
                            <option value="image/png">PNG (.png)</option>
                            <option value="image/webp">WebP (.webp)</option>
                        </select>
                    </div>

                    <!-- Quality Slider -->
                    <div>
                        <label for="conversionQualityInput" class="block text-sm font-medium mb-1 flex justify-between">
                            <span>Quality (for JPG/WebP)</span>
                            <span id="qualityValue">90%</span>
                        </label>
                        <input type="range" id="conversionQualityInput" min="10" max="100" value="90" step="5" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        <p class="text-xs text-gray-400 mt-1">Lower quality reduces file size significantly.</p>
                    </div>

                    <!-- Background Color Input -->
                    <div>
                        <label for="bgColorInput" class="block text-sm font-medium mb-1">Background Color (for JPG)</label>
                        <input type="color" id="bgColorInput" value="#1A1A1A" class="w-full h-10 p-1 bg-gray-700 border border-gray-600 rounded-md cursor-pointer">
                        <p class="text-xs text-gray-400 mt-1">Used if converting transparent PNG/GIF to JPG.</p>
                    </div>
                </div>

                <button id="convertBtn" class="btn-action w-full mt-6 py-3 rounded-lg disabled:opacity-50" disabled>
                    <i class="fas fa-exchange-alt mr-2"></i> Convert Only & Download
                </button>
            </div>
        </div>

    </div>

    <script>
        // --- GLOBAL VARIABLES ---
        let globalFile = null;
        let globalImg = null;

        // --- UTILITY FUNCTIONS ---
        
        // Displays a message in the status area
        function displayMessage(message, type = 'info') {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.textContent = message;
            statusDiv.classList.remove('hidden', 'text-yellow-400', 'text-green-400', 'text-red-400', 'bg-red-900/30', 'bg-green-900/30', 'bg-yellow-900/30');

            if (type === 'success') {
                statusDiv.classList.add('text-green-400', 'bg-green-900/30');
            } else if (type === 'error') {
                statusDiv.classList.add('text-red-400', 'bg-red-900/30');
            } else {
                statusDiv.classList.add('text-yellow-400', 'bg-yellow-900/30');
            }
        }
        
        // Helper to calculate new dimensions while maintaining aspect ratio
        function calculateNewDimensions(originalWidth, originalHeight, targetWidth, targetHeight) {
            let newWidth = originalWidth;
            let newHeight = originalHeight;

            const reqWidth = targetWidth > 0 ? targetWidth : null;
            const reqHeight = targetHeight > 0 ? targetHeight : null;
            
            // If neither is requested, return original
            if (!reqWidth && !reqHeight) {
                return { width: originalWidth, height: originalHeight };
            }

            // Case 1: Both width and height are requested (fit inside box)
            if (reqWidth && reqHeight) {
                const widthRatio = reqWidth / originalWidth;
                const heightRatio = reqHeight / originalHeight;
                const ratio = Math.min(widthRatio, heightRatio);
                
                // If image is already smaller than requested box, don't upscale
                if (ratio >= 1) { 
                    newWidth = originalWidth;
                    newHeight = originalHeight;
                } else {
                    newWidth = originalWidth * ratio;
                    newHeight = originalHeight * ratio;
                }
            } 
            // Case 2: Only width is requested (scale proportionally)
            else if (reqWidth) {
                const ratio = reqWidth / originalWidth;
                newWidth = reqWidth;
                newHeight = originalHeight * ratio;
            } 
            // Case 3: Only height is requested (scale proportionally)
            else if (reqHeight) {
                const ratio = reqHeight / originalHeight;
                newWidth = originalWidth * ratio;
                newHeight = reqHeight;
            }
            
            // Return rounded integers
            return {
                width: Math.round(newWidth),
                height: Math.round(newHeight)
            };
        }


        // --- CORE PROCESSING LOGIC ---
        async function processImage(actionType) {
            displayMessage(`Starting image processing...`, 'info');
            
            if (!globalImg) {
                displayMessage('No image selected. Please upload an image first.', 'error');
                return;
            }

            try {
                const originalWidth = globalImg.naturalWidth;
                const originalHeight = globalImg.naturalHeight;
                let targetWidth = originalWidth;
                let targetHeight = originalHeight;
                
                const targetFormatInput = document.getElementById('targetFormatInput');
                const conversionQualityInput = document.getElementById('conversionQualityInput');
                const bgColorInput = document.getElementById('bgColorInput');

                let targetFormat = targetFormatInput.value; 
                let quality = parseFloat(conversionQualityInput.value) / 100;

                // --- 1. Determine Target Dimensions based on actionType ---
                if (actionType === 'resize') {
                    const widthInput = document.getElementById('widthInput');
                    const heightInput = document.getElementById('heightInput');
                    const reqWidth = parseInt(widthInput.value, 10);
                    const reqHeight = parseInt(heightInput.value, 10);
                    
                    if (reqWidth > 0 || reqHeight > 0) {
                        const calculated = calculateNewDimensions(
                            originalWidth, 
                            originalHeight, 
                            reqWidth, 
                            reqHeight
                        );
                        targetWidth = calculated.width;
                        targetHeight = calculated.height;
                    }
                } 
                // If actionType is 'convert', target dimensions remain original.

                // --- 2. Determine Target Format and Quality ---
                if (targetFormat === 'original') {
                    // Use original MIME type and default high quality
                    targetFormat = globalFile.type;
                    quality = 0.95; 
                }
                
                if (isNaN(quality) || quality < 0.1) quality = 0.9;
                
                displayMessage(`Processing image to ${targetWidth}x${targetHeight} in ${targetFormat} @ ${Math.round(quality * 100)}%...`, 'info');


                // --- 3. Canvas Creation and Drawing ---
                const canvas = document.createElement('canvas');
                canvas.width = targetWidth;
                canvas.height = targetHeight;
                const ctx = canvas.getContext('2d');
                
                // Fill background if converting to non-transparent format (e.g., JPG)
                if (targetFormat.includes('jpeg') || targetFormat.includes('webp')) {
                    ctx.fillStyle = bgColorInput.value;
                    ctx.fillRect(0, 0, targetWidth, targetHeight);
                }

                // Draw the image at the target size
                ctx.drawImage(globalImg, 0, 0, targetWidth, targetHeight);

                // --- 4. Blob Generation (Promisified) ---
                const blob = await new Promise((resolve, reject) => {
                    // Check if the browser supports the requested format for toBlob
                    try {
                        // NOTE: toBlob requires image/ format, not .extension format
                        canvas.toBlob(resolve, targetFormat, quality);
                    } catch (e) {
                        reject(new Error(`Browser error during toBlob: ${e.message}. Try another format.`));
                    }
                });

                if (!blob) {
                    throw new Error("Failed to generate image blob. Check format and quality settings.");
                }
                
                // --- 5. Downloading ---
                const downloadUrl = URL.createObjectURL(blob);
                
                // Create filename
                const originalName = globalFile.name.substring(0, globalFile.name.lastIndexOf('.')) || 'image';
                
                // Get extension from the target MIME type
                let extension = targetFormat.split('/').pop();
                if (extension === 'jpeg') extension = 'jpg';
                
                const fileName = `${originalName}_optimized.${extension}`;
                
                // Add dimensions to filename if resized
                if (targetWidth !== originalWidth || targetHeight !== originalHeight) {
                    const dimensionTag = `${targetWidth}x${targetHeight}`;
                    const parts = fileName.split('.');
                    parts.splice(parts.length - 1, 0, dimensionTag);
                    fileName = parts.join('.');
                }

                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // Clean up
                URL.revokeObjectURL(downloadUrl);
                
                displayMessage(`Success! Downloaded file: ${fileName} (${(blob.size / 1024).toFixed(2)} KB)`, 'success');

            } catch (error) {
                console.error("Image Processing Error:", error);
                displayMessage(`An error occurred during processing: ${error.message}`, 'error');
            }
        }


        // --- UI & EVENT HANDLERS ---

        // Checks if action buttons should be enabled
        function checkEnableButtons() {
            const resizeBtn = document.getElementById('resizeBtn');
            const convertBtn = document.getElementById('convertBtn');
            
            const widthValue = document.getElementById('widthInput').value.trim();
            const heightValue = document.getElementById('heightInput').value.trim();
            const targetFormat = document.getElementById('targetFormatInput').value;
            const qualityValue = document.getElementById('conversionQualityInput').value;
            document.getElementById('qualityValue').textContent = `${qualityValue}%`;

            const isImageLoaded = globalImg !== null;
            
            // Enable Resize button if image is loaded AND at least one dimension is set
            const canResize = isImageLoaded && (widthValue !== '' || heightValue !== '');
            resizeBtn.disabled = !canResize;
            
            // Enable Convert ONLY button if image is loaded AND format is not original OR quality is explicitly changed
            const isFormatChanged = targetFormat !== 'original';
            const isQualityChanged = qualityValue !== '90';
            
            const canConvert = isImageLoaded && (isFormatChanged || isQualityChanged);
            convertBtn.disabled = !canConvert;
        }
        
        // Handles file input change or drop event
        function handleFileSelection(file) {
            if (!file || !file.type.startsWith('image/')) {
                displayMessage('Please select a valid image file.', 'error');
                globalFile = null;
                globalImg = null;
                document.getElementById('imagePreview').classList.add('hidden');
                document.getElementById('imageInfo').classList.add('hidden');
                document.getElementById('placeholderText').classList.remove('hidden');
                checkEnableButtons();
                return;
            }

            globalFile = file;
            displayMessage(`Image selected: ${file.name}`, 'info');

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    globalImg = img;
                    
                    const preview = document.getElementById('imagePreview');
                    preview.src = img.src;
                    preview.classList.remove('hidden');
                    document.getElementById('placeholderText').classList.add('hidden');
                    
                    const info = document.getElementById('imageInfo');
                    info.textContent = `${img.naturalWidth} x ${img.naturalHeight} | ${(file.size / 1024).toFixed(1)} KB`;
                    info.classList.remove('hidden');
                    
                    // Clear and set placeholders
                    document.getElementById('widthInput').value = '';
                    document.getElementById('widthInput').placeholder = img.naturalWidth;
                    document.getElementById('heightInput').value = '';
                    document.getElementById('heightInput').placeholder = img.naturalHeight;
                    
                    checkEnableButtons();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        // --- INITIALIZATION ---
        function initApp() {
            const dropZone = document.getElementById('dropZone');
            const fileInput = document.getElementById('fileInput');
            const resizeBtn = document.getElementById('resizeBtn');
            const convertBtn = document.getElementById('convertBtn');
            const qualityInput = document.getElementById('conversionQualityInput');
            const widthInput = document.getElementById('widthInput');
            const heightInput = document.getElementById('heightInput');
            const targetFormatInput = document.getElementById('targetFormatInput');

            // --- Drop Zone Listeners ---
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
            });
            dropZone.addEventListener('dragenter', () => dropZone.classList.add('drop-zone-active'), false);
            dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drop-zone-active'), false);
            dropZone.addEventListener('drop', (e) => {
                preventDefaults(e);
                dropZone.classList.remove('drop-zone-active');
                const dt = e.dataTransfer;
                if (dt.files.length > 0) { handleFileSelection(dt.files[0]); }
            }, false);
            dropZone.onclick = () => fileInput.click();
            fileInput.onchange = (e) => {
                if (e.target.files.length > 0) { handleFileSelection(e.target.files[0]); }
            };

            // --- Action Button Listeners ---
            // 'resize' action will recalculate dimensions AND use conversion settings
            resizeBtn.addEventListener('click', () => processImage('resize'));
            
            // 'convert' action will use ORIGINAL dimensions AND conversion settings
            convertBtn.addEventListener('click', () => processImage('convert'));

            // --- Input Change Listeners (to check button status) ---
            widthInput.addEventListener('input', checkEnableButtons);
            heightInput.addEventListener('input', checkEnableButtons);
            qualityInput.addEventListener('input', checkEnableButtons);
            targetFormatInput.addEventListener('change', checkEnableButtons);
            
            // Set initial state
            checkEnableButtons();
        }

        window.onload = initApp;
    </script>
</body>
</html>
